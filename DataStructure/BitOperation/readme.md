# Bit Operation 位运算

## 位运算

计算机底层硬件对数据的存储是以二进制位的形式，因此位运算是真正契合计算机原理的运算方式。有一部分运算目的是必须通过位运算完成的，而大多数情况采用位运算是一种极致主义的优化，一般的四则运算都要比运算花费更多地时钟周期，例如完成乘2的操作 `x * 2`会比`x << 2`多很多时钟周期。位运算带来的优化大多来自于计算机底层体系结构和数据存储原理，熟悉位运算的原理对于理解计算机工作原理也大有裨益。

## 常用位运算操作


####  代码中展示的常用位运算操作

| **function** | **explain** |
| :---- | :------- | 
| getNumberOf1 | 求整数二进制表示中1的个数 |
| Power | O(logn)的求幂运算 |
| getSign | 获取一个整数的符号 |
| isPowerOf2 | 判断一个整数是否是2的幂 |
| OppositeSigns | 判断两整数是否同号 |
| getAbsoluteValue | 获取一个整数的绝对值 |
| max(min) | 求两个数的最大(小)值 |
| swap | 交换两个整数变量的值 |

#### 样例说明

以下就获取一个整数的符号详细说明位运算的优化原理。判断一个整数的符号，最直观的想法是采用以下的代码
```C++
bool getSign(int v) {
	if (v >= 0)
		return 0;
	else
		return -1;
}

```
如果感兴趣可以尝试编译这段代码查看其生成的汇编代码。首先注意到这段代码采用了分支(branch)结构，即if-else语句，未经优化的情况下，在流水线计算机上通常会采用分支预测的技术来提前分支指令的执行，而分支预测错误的代价往往是整个流水线已经进行的运算会被废除。所以在编程时，尽可能的避免分支能够提成CPU的计算效率。采用`sign = -(v < 0);`避免了分支，但是仍然进行了比较，即`v < 0`，以IA32体系结构为例，这一步运算会被编译为xor %eax %eax(假设变量v的值存储在eax这个通用寄存器)，然后通过cmp指令判断xor指令的结果，并通过setl指令更改标志寄存器(CF SF ZF OF ...)。而`sign = -(int)((unsigned int)((int)v) >> (sizeof(int) * CHAR_BIT - 1));`通过位运算就避免了对标志寄存器的更改，减少了一条指令。对这里的类型转换进行一些说明，如果想得到正确的结果，必须保证“>>”操作执行的是算数右移。也就是右移时，高位补符号位。这样如果是负数的话，最高位为1，右移之后结果为（假设int占32 bits）：0xFFFFFFFF，也就是结果为-1（0xFFFFFFFF是-1的补码）。但并不是所有平台的所有编译器的“>>”操作都是算数右移，有些是逻辑右移。也就是对于有符号数，右移时高位补充的是0。这样就得不到正确的结果了（对于负数，最终表达式的结果却是1）。先将v转换为无符号数，c/c++标准已经规定，对于无符号数，“>>”操作高位补的肯定是0。这样右移(sizeof(int) * CHAR_BIT - 1)之后，负数得到的结果就是1，0或者正数得到的结果就是0。再加上前面的负号，这样负数的最终结果就是-1，正数和0的最终结果就是0。

更多关于位运算的原理和技巧可以参考来自斯坦福大学的[bithacks](http://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2)