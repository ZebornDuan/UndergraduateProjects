# Linked List 链表

链表是通过指针连接的线性数据结构，通常具有O(1)的增删复杂度和O(n)的访问复杂度。对链表的操作通常涉及到复杂和繁琐的指针操作，设计相关算法时要注意对极端情况的特别判断。在操作系统内核中，连续物理内存的管理和就绪进程的管理都会用到链表。

## 单向链表的基本操作

#### 单向链表的反向

单向链表的反向是对单向链表的基本操作。首先要注意对空链表和单结点链表的判断。删除过程需要用到三个额外的结点指针，分别用于记录当前结点及其前驱和后继结点。最后要记得对链表的原头指针做特殊处理，即将其next属性置空。

#### 单向链表的逆序访问

1. 当允许对链表结构进行修改时，可以直接将翻转链表后顺序访问；
2. 当不允许对链表结构进行修改时，一种方法是采用递归，另一种方法是采用一个栈记录待访问的序列。采用栈需要O(n)的额外空间，采用递归不需要额外的空间但在函数调用过程中系统传递参数及进程栈空间的开销较大。

#### 单向链表的结点删除

在不知道链表头指针的情况下，单向链表的结点删除实际上的不可做的，因为无法获得结点的前驱并对其进行修改。

如下的代码能够在逻辑上实现单向链表的删除：
```c++
typedef struct Node_ {
	int value = 0;
	Node_ *next = NULL;
} Node;

void remove(Node *to_del) {
	to_del->value = to_del->next->value;
	Node *t = to_del->next;
	to_del->next = to_del->next->next;
	delete t;
}
```
这段代码的实现逻辑在于将待删除结点的后继结点拷贝为当前结点，并将其后继结点删除。其中的BUG在于无法删除链表的尾结点。此外，通常在实际的工程中，一个链表结点通常是一个复杂的结构，对其的拷贝可能意味着极大的系统开销，且如果其他结构包含对链表结点的引用，上述删除方式也会破坏待删除结点的后继结点的其他引用的正确性。

## 单向链表的相交与成环问题

#### 成环判断与环入口

一种简单的方法是对链表结点进行哈希，寻找首次发生冲突的结点即为链表环的入口。参考如下的代码：
```c++
Node* EntryNodeOfLoop(Node* Head) {
    if(!pHead) 
    	return NULL;
    map<Node*, int> flag;
    while (pHead) {
        if (++flag[pHead] == 2)
            return pHead;
        pHead=pHead->next;
    }
    return NULL; 
}
```
基于链表操作的算法是快慢指针法。参考代码中的`isLoop`函数。这里对快慢指针法的原理进行推导。
```
           E
  _ _ _ _ _ _ _ _
 A         |_ _ _| B

 在如上的示意图中，设链表头为A点，环的入口为E点，两指针相遇在B点。设环之前的长度(AE)为x，入口到相遇点的长度(EB，顺时针)为a，环的长度(EBE)为c。
 快指针一次走两步，慢指针一次走一步。则当两指针相遇时有：
 s1 = x + m * c + a //slow
 s2 = x + n * c + a //fast
 2 * s1 = s2        //m, n为任意非负整数
 解得：x = (n - 2 * m ) * c - a = (n - 2 *m -1 ) * c + c - a
 即x是环的长度的整数倍(可能为0)再加上相遇点到环入口的距离。那么此时如果让两个指针分别从链表头和相遇点出发，一次走一步，那么他们一定会在环的入口点相遇。
 算法的时间复杂度为O(n),空间复杂度为O(1)。

 这个方法在密码学中寻找Hash函数的碰撞中也有用到。
```
当已经确定链表中有环时，且允许对链表结构进行破坏，则还可采用断链的方法找到链表环的入口。参考代码中的`findEntryOfLoop`函数。

#### 链表相交的判断与入口

链表若相交则其结构一定是‘Y’字型，极端情况是‘I’字性。这样只需要使用两个指针分别对两个链表进行遍历，并以两指针相遇为结束条件，当其中一个链表遍历到尾部时，应该转移到另一个链表的头部继续遍历，这样最多两次遍历，两指针必然相遇。

下面分情况具体讨论：
设两链表公共部分长度为l，链表1在公共结点前的长度为x1，链表2在公共结点前的长度为x2。
1. 两链表长度相同，且不相交。则x1=x2，l=0。那么两指针均走过x1（x2）距离后在NULL处相遇。
2. 两链表长度相同，且相交。则x1=x2，l！=0。那么两指针均走过x1（x2）距离后在公共结点处相遇。
3. 两链表长度不同，且不想交。则x1！=x2，l=0。那么分别走过x1+x2和x2+x1后在NULL处相遇。
4. 两链表长度相同，且相交。则x1=x2，l！=0。那么分别走过x1+l+x2和x2+l+x1后在公共结点处相遇。

最终返回相遇点即可，若为空则表示两链表不相交，否则即为相交的入口结点。算法为O(n)的时间复杂度，O(1)的空间复杂度。

## 双向链表

双向链表由于与前后都有连接，在基本操作上相比于单向链表较为简单。有时候为了方便，会在双向链表的两端加上两个哨兵结点。从以上单向链表的讨论中可以注意到，单向链表的翻转操作是O(n)的时间复杂度，插入和删除是O(1)时间复杂度。基于双向链表可以做到插入，删除以及翻转都是O(1)时间复杂度。实现这个操作却也伴随着较大的常数因子，因此，只有在数据规模较大时，O(1)的翻转复杂度才能体现出优势。

参考如下练习，题目来源于清华大学计算机系数据结构课程2016秋季学期PA1-6。
输入输出样例与参考代码见`answer.cpp`，为了提高操作效率，代码中基于数组实现逻辑上的链表，这种方法在二叉树类的问题中比较常见，此代码在清华大学的OJ上评测结果为规模最大的测试点用时为420ms。
```
因为x是天才，所以经常处理一些文本信息。但是因为需要处理的东西实在是太多啦，所以x发明了一个完美的文本编辑器。
这个编辑器拥有两个光标（cursor），所以x能够同时在两处地方插入和删除文本。
这个编辑器除了正常的编辑功能以外，还有一些只有x才知道用处的功能，例如翻转两个光标之间的文本。
某一天，x把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。
于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。
```

功能列表如下：


| **功能名称** | **命令格式** | **说明** |
| :---------- | :----------- | :----------------- |
| < (move left) | < w | w 为一个字符，不是“L”就是“R”，代表是为左光标还是右光标（下同）。该命令将选定光标向左移动，如果已经是最左端则不移动。 命令执行成功时输出“T”，否则（此时光标已经在最左端）输出“F”。 |
| > (move right) | > w | w 同上。与F 命令不同的是，该命令将光标向右移动。命令执行成功时输出“T”，否则（光标已经在最右端）输出“F”。 |
| I (insert) | I w c | w 同上。c 是一个可见字符(33 ≤ ascii码 ≤ 126)，代表在该光标左插入该字符。该命令始终输出“T”。 |
| D (delete) | D w | w 同上。代表删除该光标右的一个字符。命令执行成功时输出“T”，否则（此时光标右侧没有字符）输出“F”。 |
| R (reverse) |	R |	代表翻转左光标和右光标之间的字符。该命令只有左光标在右光标左侧时才能执行（两光标重合时也不能执行）。 命令执行成功时输出“T”，否则输“F”。 |
| S (show) | S | 代表显示当前处理的文本。该命令只输出文本，不输出“T”或“F”。 |

```
开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。

注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。

输入：第一行是初始时文本编辑器内容。第二行是一个正整数N，N表示操作次数。接下来有N行，每行有一个命令，命令格式如上方表格。

输出：对于每个命令，按上方表格要求执行并输出。

数据范围：1 ≤ 初始文本长度 ≤ 4,000,000，1 ≤ N ≤ 4,000,000，输出文件大小 ≤ 20 MB。

资源限制：时间：1 s，空间：256 MB。

```

## 练习 

- 有序单向链表的合并（迭代与递归）

给定两个非降序的单向链表，将这两个链表合并为一个非降序的链表。

- 基于单向链表的整数加法

通过单向链表给出两个十进制整数，请基于单向链表完成两个整数的加法。不要将链表转化为十进制数相加后再转为链表结构。
```
例：      1 -> 2 -> 3 -> 4
      +             6 -> 8
      ---------------------
          1 -> 3 -> 0 -> 2
```

- 单向链表回文结构的判断

给定一个单向链表，判断链表是否是回文结构，形如“123321”与“123454321”的串都属于回文结构。

- 判断两个有环链表是否相交

